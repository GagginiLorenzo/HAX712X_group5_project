[
  {
    "objectID": "polluants/SO2.html",
    "href": "polluants/SO2.html",
    "title": "SO2 : dioxyde de soufre",
    "section": "",
    "text": "C’est un indicateur de la pollution liée aux combustibles fossiles.\nImpact sur la santé Le dioxyde de soufre affecte le système respiratoire, le fonctionnement des poumons et provoque des irritations oculaires. L’inflammation de l’appareil respiratoire entraine de la toux, une production de mucus, une exacerbation l’asthme, des bronchites chroniques et une sensibilisation aux infections respiratoires.\nImpact sur l’environnement Concernant l’environnement, il contribue aux pluies acides, qui appauvrissent les milieux naturels (sols et végétaux) et dégradent les bâtiments.\nSource Le dioxyde de soufre est émis lors de la combustion de matières fossiles, telles que le charbon, le pétrole et certains gaz contenant des impuretés en soufre, et lors de certains procédés industriels. Il est rejeté à plus de 50% par les activités industrielles, dont celles liées à la production d’énergie comme les centrales thermiques. Mais il est également émis par le chauffage résidentiel, commercial ou des entreprises. Les émissions de dioxyde de souffre dépendent de la teneur en soufre de ces combustibles."
  },
  {
    "objectID": "polluants/O3.html",
    "href": "polluants/O3.html",
    "title": "O3 : ozone",
    "section": "",
    "text": "L’ozone est formé à partir de réactions chimiques entre les oxydes d’azote (NOx) et les composés organiques volatils (COV), sous l’effet du soleil. Comme il n’est pas émis directement dans l’air, on dit qu’il s’agit d’un polluant secondaire.\nImpact de l’ozone sur la sante\nL’ozone a un impact important sur la santé : il peut pénétrer profondément dans l’appareil respiratoire et provoquer une réaction inflammatoire bronchique au niveau cellulaire, d’où une toux sèche et une gêne respiratoire. Des effets cardiovasculaires sont également constatés. L’augmentation des niveaux d’ozone est corrélée à une augmentation des hospitalisations et à des décès prématurés."
  },
  {
    "objectID": "polluants/H2S.html",
    "href": "polluants/H2S.html",
    "title": "H2S : hydrogène sulfuré",
    "section": "",
    "text": "L’hydrogène sulfuré (H2S) est un gaz incolore, composant naturel du pétrole, à odeur caractéristique d’œufs pourris. Il se dégage des matières organiques en décomposition ou lors de l’utilisation du souffre et des sulfures dans l’industrie chimique. Étant plus lourd que l’air, il s’accumule dans les parties basses non ventilées…\nLe dégagement se produit :\n\nEn présence de matières ou résidus organiques ou minéraux (production de sulfures)\nDans un espace confiné Sous l’effet d’une acidification (qui dépend du pH du milieu).\n\nNB : la perception olfactive est décelable à très faible concentration mais ne constitue pas un seuil d’alerte suffisant car elle s’atténue jusqu’à disparaître au fur et à mesure qu’augmente la concentration de gaz (effet de sidération olfactive).\nQuels sont les risques ?\nL’hydrogène sulfuré est un gaz toxique qui pénètre par les voies respiratoires. Compte tenu de son caractère insidieux, l’exposition à ce gaz revêt souvent un caractère accidentel qui peut être fatal.\nRisques pour la santé :\n\nDes intoxications aiguës (exposition de courte durée) : troubles respiratoires, irritations oculaires, conjonctivites, vertiges, céphalées, œdème aigu du poumon, pertes de connaissance (« plomb des vidangeurs »)\nDes intoxications chroniques (exposition prolongée) : bronchites irritatives, irritations cutanées\nDes pertes de connaissance à partir de 500 ppm\nUne possibilité d’accident mortel très rapide en cas de fortes inhalations (&gt; 1000 ppm)"
  },
  {
    "objectID": "q.html",
    "href": "q.html",
    "title": "Occitanie Quality Air Explorer",
    "section": "",
    "text": "Carte des stations d’Occitanie\n\n#| standalone: true\n#| viewerHeight: 1600\n#| column: page\n\nimport matplotlib.pyplot as plt\nimport time\nfrom ipywidgets import HTML, Layout\nimport ipyleaflet as L\nimport json\nimport random\nimport pandas as pd\nfrom io import StringIO  # Importez StringIO depuis io\nfrom shiny import App, render, ui,reactive \nfrom shinywidgets import output_widget, reactive_read, render_widget, register_widget\nimport pyodide.http\nimport pandas\nfrom branca.colormap import LinearColormap, linear\nfrom datetime import datetime\nfrom shiny import App, Inputs, Outputs, Session, reactive, ui\npolluant_atmos=\"'O3'\",\"'NO2'\",\"'NO'\",\"'NOX'\",\"'H2S'\",\"'PM10'\",\"'PM2.5'\",\"'SO2'\"\n\napp_ui = ui.page_fluid(   \n    ui.input_selectize(\"condition1\", \"Polluant\", polluant_atmos,multiple = True),\n    ui.output_text_verbatim(\"info1\"),\n    ui.output_text_verbatim(\"Clicks\"),\n    output_widget(\"map\",height='500px'),\n    ui.output_plot(\"GRAPH_YEAR\",height='800px')\n    )\n\ndef server(input, output, session):\n\n    def url0():\n        vi=str(city.get())\n        cond1 = \"(nom_poll=\"+ ') AND ('.join(input.condition1())+')'\n        return f\"https://services9.arcgis.com/7Sr9Ek9c1QTKmbwr/arcgis/rest/services/Mesure_horaire_(30j)_Region_Occitanie_Polluants_Reglementaires_1/FeatureServer/0/query?where=(code_station='{vi}')AND{cond1}&outFields=nom_dept,nom_station,nom_com,nom_poll,valeur,date_debut,date_fin&outSR=4326&f=json\"\n    @reactive.Calc\n    async def data0():\n        response0 = await pyodide.http.pyfetch(url0())\n        dat = await response0.json()\n        r= dat\n        return r\n\n    def url1():\n        cond1 = \"where=(nom_poll=\"+ ') AND ('.join(input.condition1())+')'\n        return f\"https://services9.arcgis.com/7Sr9Ek9c1QTKmbwr/arcgis/rest/services/mesures_occitanie_mensuelle_poll_princ/FeatureServer/0/query?{cond1}&outFields=nom_dept,nom_station,nom_com,nom_poll,valeur,date_debut,date_fin&outSR=4326&f=json\"\n    @reactive.Calc\n    async def data1():\n        response1 = await pyodide.http.pyfetch(url1())\n        dat = await response1.json()\n        r= dat\n        return r\n\n    def url2():\n        return \"https://france-geojson.gregoiredavid.fr/repo/regions/occitanie/departements-occitanie.geojson\"\n    @reactive.Calc\n    async def data2():\n        response1 = await pyodide.http.pyfetch(url2())\n        dat1 = await response1.json()\n        r= dat1\n        return r\n\n\n    @reactive.Calc\n    async def polluant_data():\n        '''\n        FOnction qui place les différentes stations cliquable sur la carte\n        '''\n        r= await data1()\n        records = r.get('features', [])\n        records_data = [record['attributes'] for record in records]\n        df_atmo = pd.DataFrame(records_data)\n        df_atmo[\"date_debut\"] = df_atmo[\"date_debut\"]/1000\n        df_atmo[\"date_debut\"] = df_atmo[\"date_debut\"].apply(\n                    lambda _: datetime.utcfromtimestamp(_)\n                )\n        df_atmo[\"nom_dept\"]=df_atmo[\"nom_dept\"].str.title()\n        dataO3 = df_atmo.groupby(['nom_dept']).max().reset_index()\n        df = pd.DataFrame(dataO3)\n        return df\n    \n    markers = [\n        L.Marker(location=(43.5915, 3.88681), title=\"FR50200\", draggable=False),\n        L.Marker(location=(43.6113, 3.86626), title=\"FR50201\", draggable=False),\n        L.Marker(location=(43.6051, 3.87464), title=\"FR50202\", draggable=False),\n        L.Marker(location=(43.60994829, 3.898617657), title=\"FR50203\", draggable=False),\n        L.Marker(location=(43.6926, 3.80021), title=\"FR50204\", draggable=False),\n        L.Marker(location=(43.5705, 3.91168), title=\"FR50205\", draggable=False),\n        L.Marker(location=(43.61156038, 3.827978983), title=\"FR50225\", draggable=False),\n        L.Marker(location=(43.57570439, 1.418072093), title=\"FR50004\", draggable=False),\n        L.Marker(location=(43.62358041, 1.438546479), title=\"FR50021\", draggable=False),\n        L.Marker(location=(43.5873309, 1.444026232), title=\"FR50030\", draggable=False),\n        L.Marker(location=(43.56158117, 1.393260062), title=\"FR50039\", draggable=False),\n        L.Marker(location=(43.55641203, 1.403924525), title=\"FR50040\", draggable=False),\n        L.Marker(location=(43.45729083, 1.571484804), title=\"FR50041\", draggable=False),\n        L.Marker(location=(43.62530339, 1.377245933), title=\"FR50043\", draggable=False),\n        L.Marker(location=(43.63347292, 1.375719756), title=\"FR50044\", draggable=False),\n        L.Marker(location=(43.57401353, 1.449589136), title=\"FR50048\", draggable=False),\n        L.Marker(location=(43.64305339, 1.46765185), title=\"FR50054\", draggable=False),\n        L.Marker(location=(43.61032645, 1.415181756), title=\"FR50821\", draggable=False),\n        L.Marker(location=(43.8344, 4.37419), title=\"FR50211\", draggable=False),\n        L.Marker(location=(43.8299, 4.36199), title=\"FR50212\", draggable=False),\n        L.Marker(location=(43.9254, 4.26581), title=\"FR50213\", draggable=False),\n        L.Marker(location=(42.6955, 2.90053), title=\"FR50220\", draggable=False),\n        L.Marker(location=(42.7198, 2.83988), title=\"FR50221\", draggable=False),\n        L.Marker(location=(42.69593509, 2.888446527), title=\"FR50224\", draggable=False),\n        L.Marker(location=(43.09377548, 0.743792653), title=\"FR50015\", draggable=False),\n        L.Marker(location=(43.10560652, 0.719296038), title=\"FR50016\", draggable=False),\n        L.Marker(location=(43.62872527, 0.179064274), title=\"FR50020\", draggable=False),\n        L.Marker(location=(43.92781137, 2.145879865), title=\"FR50026\", draggable=False),\n        L.Marker(location=(43.88395379, 0.845617354), title=\"FR50029\", draggable=False),\n        L.Marker(location=(43.44175891, 1.821396947), title=\"FR50031\", draggable=False),\n        L.Marker(location=(43.09624528, -0.040493309), title=\"FR50042\", draggable=False),\n        L.Marker(location=(43.80318072, 1.595487893), title=\"FR50047\", draggable=False),\n        L.Marker(location=(43.23035205, 0.062463284), title=\"FR50052\", draggable=False),\n        L.Marker(location=(43.61043594, 2.230208516), title=\"FR50053\", draggable=False),\n        L.Marker(location=(44.01285657, 1.375305225), title=\"FR50060\", draggable=False),\n        L.Marker(location=(43.6758, 4.08838), title=\"FR50206\", draggable=False),\n        L.Marker(location=(43.4068, 3.18878), title=\"FR50209\", draggable=False),\n        L.Marker(location=(43.2875, 3.50484), title=\"FR50210\", draggable=False),\n        L.Marker(location=(43.9426, 4.67958), title=\"FR50216\", draggable=False),\n        ]\n\n    city = reactive.Value('')\n    def on_click(marker):\n        def click_handler(**kwargs):\n            city.set(marker.title)\n        return click_handler\n    for i, marker in enumerate(markers, start=1):\n        click_handler = on_click(marker)\n        marker.on_click(click_handler)\n\n    @output\n    @render_widget\n    async def map():\n        '''\n        fonction qui \n            - trace la carte d'Occitanie \n            - nous centre dessus\n            - mets des couleurs aux départements en fonction de la valeur du polluant choisi.\n        '''\n        g=await data2()\n        geojson=g\n        df= await polluant_data()\n        \n        mymap = L.Map(center=[43.6, 1.44],zoom=7,layout=Layout(height='500px'),)\n        colormap= linear.YlOrRd_09.scale(df['valeur'].min(), df['valeur'].max())\n\n        for feature in geojson['features']:\n            station = df[df['nom_dept'] == feature['properties']['nom']]\n            if not station.empty:\n                value = station['valeur'].values[0]\n                color = colormap.rgb_hex_str(value)\n            else:\n                color = '#e5f5e0'  # Couleur hexadécimale pour les polygones sans données\n            geo_json = L.GeoJSON(\n            data=feature,\n            style={\n                'opacity': 1, 'dashArray': '9', 'fillOpacity': 1, 'weight': 1,\n                'fillColor': color\n            },\n            hover_style={\n                'color': 'white', 'dashArray': '0', 'fillOpacity': 0.5\n            },\n            )\n            mymap.add(geo_json)\n        for i in range(39):\n            mymap.add(markers[i])\n        control = L.LayersControl(position='topright')\n        mymap.add(control)\n        \n        return mymap\n\n    @output\n    @render.text\n    def Clicks():\n        return \"station: \" + str(city.get())\n\n    @output\n    @render.plot\n    async def GRAPH_YEAR():\n        '''\n        fonction qui \n            - récupère le résultat de l'appel le dictionnaire issu de data()\n            - transforme en dataframe\n            - trace le graphique temporel du polluant choisi dans la ville choisi par le click\n        '''\n        tps1 = time.time()\n        #supprimer les warnings\n        pd.options.mode.chained_assignment = None  # default='warn'\n\n        response = await data0()\n        dat = response\n\n        records = dat.get('features', [])\n        records_data = [record['attributes'] for record in records]\n        df_atmo= pd.DataFrame(records_data)\n\n        df_atmo[\"date_debut\"] = df_atmo[\"date_debut\"]/1000\n        df_atmo[\"date_debut\"] = df_atmo[\"date_debut\"].apply(\n                    lambda _: datetime.utcfromtimestamp(_)\n                )\n\n        # liste des villes et des polluants\n        villes = df_atmo[\"nom_com\"].unique().tolist()\n        polluants = df_atmo[\"nom_poll\"].unique().tolist()\n\n        # Fonction qui trace le graphique\n        def graphique(villes, polluants):\n            #on enlève une station double\n            if villes == \"MONTPELLIER\":\n                df_atmo[\"nom_station\"] = df_atmo[\"nom_station\"].replace([\"Montpelier Pere Louis Trafic\"], \"Montpelier Antigone Trafic\")\n            #on renomme\n            df_pv = df_atmo\n            #les différentes stations\n            nom_stations = df_pv[\"nom_station\"].unique()\n            nb_stations = len(nom_stations)\n            \n            ####cas limite 1 station\n            if nb_stations == 1:\n                fig, axes = plt.subplots(1, 1, figsize=(10, 25), layout=\"constrained\")  # Créer une seule sous-figure\n                axes = [axes]  # Mettre l'unique axe dans une liste\n            else:\n                fig, axes = plt.subplots(nb_stations, 1, figsize=(10, 25), sharex=True, layout=\"constrained\")\n            \n            #titre général\n            fig.suptitle(\"Pollution au \" + str(polluants[0]) + \" à \" + str(villes[0])+\" ces 30 derniers jours\", fontsize=12)\n            for i in range(nb_stations):             \n                df_pvs = df_pv.loc[df_pv[\"nom_station\"] == nom_stations[i]]\n                #datetime devient index\n                df_pvs = df_pvs.set_index([\"date_debut\"])\n                #on moyennise par jour\n                axes[i].plot(df_pvs[\"valeur\"].resample(\"d\").mean(),)\n                #décorations et titre\n                for label in axes[i].get_xticklabels():\n                    label.set_ha(\"right\")\n                    label.set_rotation(45)\n                axes[i].set_ylabel(\"µg/m3\")\n                axes[i].set_title(\n                    \"Concentration du \" + str(polluants[0]) + \" à \" + str(nom_stations[i]),fontsize = 12)\n                axes[i].grid(True)\n            return fig\n        return graphique(villes, polluants)\napp = App(app_ui, server)  \n\n\n\n\n\nReprésentation temporelle d’un polluant\n#| standalone: true\n#| viewerHeight: 800\n#| column: page\nfrom pprint import pformat\nimport pyodide.http\nfrom shiny import App, reactive, render, ui\nimport pandas as pd\nimport numpy as np\nfrom datetime import datetime\nimport matplotlib.pyplot as plt\n\n\n#les différentes villes\nzone_atmos=\"'AGDE'\",\"'ALES'\",\"'ARGELES-GAZOST'\",\"'AUCH'\",\"'BELESTA-EN-LAURAGAIS'\",\"'BESSIERES'\",\"'BEZIERS'\",\"'BLAGNAC'\",\"'CORNEILHAN'\",\"'GAUDONVILLE'\",\"'LA CALMETTE'\",\"'LATTES'\",\"'LOURDES'\",\"'LUNEL-VIEL'\",\"'MIRAMONT-DE-COMMINGES'\",\"'MONTGISCARD'\",\"'MONTPELLIER'\",\"'NIMES'\",\"'PEYRUSSE-VIEILLE'\",\"'SAINT-GAUDENS'\",\"'SAINT-GIRONS'\",\"'SAZE'\",\"'TARBES'\",\"'TOULOUSE'\"\n\n#les polluants\npolluant_atmos=\"'O3'\",\"'NO2'\",\"'NO'\",\"'NOX'\",\"'H2S\",\"'PM10'\",\"'PM2.5'\",\"'SO2'\"\n\n#choix des villes et des polluants\napp_ui = ui.page_fluid(\n        ui.div(\n                ui.input_selectize(\"selection1\", \"Ville\", zone_atmos,multiple = True),\n                ui.input_selectize(\"condition1\", \"Polluant\", polluant_atmos, multiple = True),\n                ui.input_date(\"date\",\"à partir de\"),\n                class_=\"d-flex gap-3\"\n                ),\n    ui.output_plot(\"GRAPH_YEAR\",height='800px'), #\n)\n\ndef server(input, output, session):\n    def url1():\n        cond1 = \"where=(nom_poll=\"+ ') AND ('.join(input.condition1())+')'\n        cond2 =  \"AND (nom_com=\"+'AND ('.join(input.selection1())+')'\n        date1= f\"AND (date_debut &gt;= '{input.date()}\"+\" 00:00:00' )\"\n        return f\"https://services9.arcgis.com/7Sr9Ek9c1QTKmbwr/arcgis/rest/services/mesures_occitanie_journaliere_poll_princ/FeatureServer/0/query?{cond1}{cond2}{date1}&outFields=nom_com,nom_station,code_station,typologie,nom_poll,valeur,date_debut,influence&outSR=4326&f=json\"\n\n    @reactive.Calc\n    async def data():\n        response1 = await pyodide.http.pyfetch(url1())\n        dat1 = await response1.json()\n        r= dat1,dat1\n        return r\n\n    @output\n    @render.plot\n    async def GRAPH_YEAR():\n        '''\n        fonction qui \n            - récupère le résultat de l'appel le dictionnaire issu de data()\n            - transforme en dataframe\n            - trace le graphique temporel\n        '''\n\n        #supprimer les warnings\n        pd.options.mode.chained_assignment = None  # default='warn'\n\n        response = await data()\n        dat = response[1]\n\n        records = dat.get('features', [])\n        records_data = [record['attributes'] for record in records]\n        df_atmo = pd.DataFrame(records_data)\n\n        # %%\n        df_atmo[\"date_debut\"] = df_atmo[\"date_debut\"]/1000\n        df_atmo[\"date_debut\"] = df_atmo[\"date_debut\"].apply(\n                    lambda _: datetime.utcfromtimestamp(_)\n                )\n\n        # liste des villes et des polluants\n        villes = df_atmo[\"nom_com\"].unique().tolist()\n        polluants = df_atmo[\"nom_poll\"].unique().tolist()\n\n        # Fonction qui trace le graphique\n        def graph_year():\n            '''\n            fonction qui trace le graphique temporel\n            '''\n            #on enlève une station double\n            if villes == \"MONTPELLIER\":\n                df_atmo[\"nom_station\"] = df_atmo[\"nom_station\"].replace([\"Montpelier Pere Louis Trafic\"], \"Montpelier Antigone Trafic\")\n            #on renomme\n            df_pv = df_atmo\n            #les différentes stations\n            nom_stations = df_pv[\"nom_station\"].unique()\n            nb_stations = len(nom_stations)\n            \n            ####cas limite 1 station\n            if nb_stations == 1:\n                fig, axes = plt.subplots(1, 1, figsize=(10, 25), layout=\"constrained\")  # Créer une seule sous-figure\n                axes = [axes]  # Mettre l'unique axe dans une liste\n            else:\n                fig, axes = plt.subplots(nb_stations, 1, figsize=(10, 25), sharex=True, layout=\"constrained\")\n            \n            #titre général\n            fig.suptitle(\"Pollution au \" + str(polluants[0]) + \" à \" + str(villes[0]), fontsize=12)\n            for i in range(nb_stations):             \n                df_pvs = df_pv.loc[df_pv[\"nom_station\"] == nom_stations[i]]\n                #datetime devient index\n                df_pvs = df_pvs.set_index([\"date_debut\"])\n                #on moyennise par jour\n                axes[i].plot(df_pvs[\"valeur\"].resample(\"d\").mean(),)\n                #décorations et titre\n                for label in axes[i].get_xticklabels():\n                    label.set_ha(\"right\")\n                    label.set_rotation(45)\n                axes[i].set_ylabel(\"µg/m3\")\n                axes[i].set_title(\n                    \"Concentration du \" + str(polluants[0]) + \" à \" + str(nom_stations[i]),fontsize = 12)\n                axes[i].grid(True)\n            return fig\n        return graph_year()\n    #@output\n    #@render.text\n    #async def info1():\n    #    if input.selection1() == \"\":\n    #        return \"\"\n    #    else:\n    #        d=await data()\n    #        df = d[1]\n    #        return f\"Request URL: {url1()}\\nResult type: {type(d[1])}\\n{df}\"\napp = App(app_ui, server, debug=True)\n\n\n\n\n\n\n\nReprésentation d’indicateurs météorologiques\n#| standalone: true\n#| viewerHeight: 800\n#| column: page\n\nfrom pprint import pformat\nimport pyodide.http\nfrom shiny import App, reactive, render, ui\nimport pandas as pd\n#import numpy as np\nfrom datetime import datetime\nimport matplotlib.pyplot as plt\n\n\n#villes pour synop\nvilles = \"'GOURDON'\",\"'MILLAU'\",\"'MONTPELLIER'\",\"'PERPIGNAN'\",\"'ST GIRONS'\",\"'TARBES-OSSUN'\", \"'TOULOUSE-BLAGNAC'\" \n\n#choix des paramètres météorologiques\nchoices_synop= \"pres\", \"tc\", \"tminsolc\", #\"nom_dept\",\"date\", \"nom\",\n\n#choix des années\ny_synop=\"2022\",\"2023\"\n\n#les mois de l'année\nm_synop=\"01\",\"02\",\"03\",\"04\",\"05\",\"06\",\"07\",\"06\",\"08\",\"09\",\"10\",\"11\",\"12\"\n\n#la sélection\napp_ui = ui.page_fluid(\n        ui.div(\n            ui.input_selectize(\"ville\", \"Ville\", villes, multiple = True),\n            ui.input_selectize(\"selection\", \"Paramètre\", choices_synop, multiple = True),\n            ui.input_selectize(\"date1\", \"Année\", y_synop, multiple = True),\n            ui.input_selectize(\"date2\", \"Mois\", m_synop, multiple = True),\n            class_=\"d-flex gap-3\"\n        ),\n    ui.output_plot(\"GRAPH_SYNOP\",height='800px')\n)\n\ndef server(input, output, session):\n    #@output\n    #@render.text\n#\n    ####test reussi, stack est une liste de n requêtes (1 par jours), avec toute les donnée occtinanie/jours (environs 60 résultas/jours),\n    ####petit exemple pour des test statiques dans code a implémenter\n#\n    #async def info():\n    #    if input.date2()==\" \" :\n    #        return \" \"\n    #    else:\n    #        stack=[]\n    #        r=[]\n    #        select = ','.join(input.selection())\n    #        year=','.join(input.date1())\n    #        month=','.join(input.date2())\n    #        ville=','.join(input.ville())\n#\n    #        ### faire les tests avec l'exrait en local pour pas se faire blacklist par l'api, on étendra une fois le graphe achevé ,'04','05','06','07','08','09','10','11','12','13','14','15','16','17','18','19','20','21','22','23','24','25','26','27','28','29','30']:\n#\n    #        for n in ['01','02','03']: \n    #            url=f\"https://public.opendatasoft.com/api/explore/v2.1/catalog/datasets/donnees-synop-essentielles-omm/records?select=date,nom,{select}&where=year(date)={year} and month(date)={month} and day(date)={n} and code_reg=76 and nom ={ville}&limit=99\"\n    #            response = await pyodide.http.pyfetch(url)\n    #            dat = await response.json()\n    #            stack.append(dat)\n    #        q=pformat(stack)\n    #    return  f\"{q}\"\n\n    @reactive.Calc\n    async def data():\n        r=[]\n        select = ','.join(input.selection())\n        year=','.join(input.date1())\n        month=','.join(input.date2())\n        ville=','.join(input.ville())\n        ### faire les tests avec l'exrait en local pour pas se faire blacklist par l'api, on étendra une fois le graph achever ,'04','05','06','07','08','09','10','11','12','13','14','15','16','17','18','19','20','21','22','23','24','25','26','27','28','29','30']:\n        stack = []\n        for n in ['01','02','03','04','05','06','07','08','09','10','11','12','13','14','15','16','17','18','19','20','21','22','23','24','25','26','27','28','29','30']: \n            url=f\"https://public.opendatasoft.com/api/explore/v2.1/catalog/datasets/donnees-synop-essentielles-omm/records?select=date,nom,{select}&where=year(date)={year} and month(date)={month} and day(date)={n} and code_reg=76 and nom ={ville}&limit=99\"\n            response = await pyodide.http.pyfetch(url)\n            dat = await response.json()\n            stack.append(dat)\n        return stack\n    \n    @output\n    @render.plot\n    async def GRAPH_SYNOP():\n        '''\n        fonction qui \n            - récupère le résultat de l'appel le dictionnaire issu de data()\n            - transforme en dataframe\n            - trace le graphique temporel du paramètre choisi dans la ville choisie en fonction du temps\n        '''\n    \n        #supprimer les warnings\n        pd.options.mode.chained_assignment = None  # default='warn'\n\n        response = await data()\n\n        def process_response(response):\n            dfs = []\n            for item in response:\n                results = item.get(\"results\", [])\n                df = pd.DataFrame(results)\n                dfs.append(df)\n\n            # Concatenate the individual DataFrames into one DataFrame\n            df_synop = pd.concat(dfs, ignore_index=True)\n\n            # Format date\n            df_synop[\"date\"] = df_synop[\"date\"].apply(lambda _: datetime.fromisoformat(_))\n\n            return df_synop\n        \n        df_synop = process_response(response)\n\n        # Fonction qui trace le graphique\n        def graph_synop(df_synop):\n            df_synop = df_synop.set_index([\"date\"])\n            fig, ax = plt.subplots(layout=\"constrained\")\n            ax.plot(df_synop.iloc[:,1].resample(\"d\").mean())\n            for label in ax.get_xticklabels():\n                label.set_ha(\"right\")\n                label.set_rotation(45)\n            ax.set_title(\"Valeur de la \" + df_synop.columns[1] + \" à \" + df_synop.iloc[1,0])\n            ax.grid(True)\n            return fig\n        return graph_synop(df_synop)\napp = App(app_ui, server, debug=True)\n\n\n\n\n\n\nReprésentation de l’influence des émetteurrs\n#| standalone: true\n#| viewerHeight: 800\n#| column: page\nfrom pprint import pformat\nimport pyodide.http\nfrom shiny import App, reactive, render, ui\nimport pandas as pd\nimport numpy as np\nfrom datetime import datetime\nimport matplotlib.pyplot as plt\n\n\n#les villes\nzone_atmos=\"'AGDE'\",\"'ALES'\",\"'ARGELES-GAZOST'\",\"'AUCH'\",\"'BELESTA-EN-LAURAGAIS'\",\"'BESSIERES'\",\"'BEZIERS'\",\"'BLAGNAC'\",\"'CORNEILHAN'\",\"'GAUDONVILLE'\",\"'LA CALMETTE'\",\"'LATTES'\",\"'LOURDES'\",\"'LUNEL-VIEL'\",\"'MIRAMONT-DE-COMMINGES'\",\"'MONTGISCARD'\",\"'MONTPELLIER'\",\"'NIMES'\",\"'PEYRUSSE-VIEILLE'\",\"'SAINT-GAUDENS'\",\"'SAINT-GIRONS'\",\"'SAZE'\",\"'TARBES'\",\"'TOULOUSE'\"     \n\n\n# La sélection\napp_ui = ui.page_fluid(\n                ui.input_selectize(\"selection1\", \"Ville\", zone_atmos,multiple = True),\n                ui.output_plot(\"GRAPH_INFLU\",height='800px'), #\n)\n\ndef server(input, output, session):\n    def url2():\n        cond1 = \"where=(nom_com=\"+ ') AND ('.join(input.selection1())+')'\n        return f\"https://services9.arcgis.com/7Sr9Ek9c1QTKmbwr/arcgis/rest/services/Mesure_horaire_(30j)_Region_Occitanie_Polluants_Reglementaires_1/FeatureServer/0/query?{cond1}&outFields=nom_com,nom_poll,valeur,influence,date_debut&outSR=4326&f=json\"\n\n    @reactive.Calc\n    async def data():\n        '''\n        fonction qui \n            - récupère le résultat de l'appel API de url2() \n        '''\n        response2 = await pyodide.http.pyfetch(url2())\n        dat2 = await response2.json()\n        r = dat2,dat2\n        return r\n\n    @output\n    @render.plot\n    async def GRAPH_INFLU():\n\n        '''\n        fonction qui \n            - récupère le résultat de l'appel le dictionnaire issu de data()\n            - transforme en dataframe\n            - trace le graphique de la valeur moyennne des polluants en fonction de la ville et du type d'émetteur \n        '''\n    \n        #supprimer les warnings\n        pd.options.mode.chained_assignment = None  # default='warn'\n\n        response = await data()\n        dat = response[1]\n\n        records = dat.get('features', [])\n        records_data = [record['attributes'] for record in records]\n        df_atmo = pd.DataFrame(records_data)\n\n        villes = df_atmo[\"nom_com\"].unique().tolist()\n\n        # Fonction qui trace le graphique\n        def graph_influ():\n            pol_influ = df_atmo.groupby(['influence', 'nom_poll'])['valeur'].mean().round(1).unstack(level=0)\n            polluants = pol_influ.index.tolist()\n            # position des labels et tracé du graphique\n            x = np.arange(len(polluants)) + 1  # the label locations\n            width = 0.25  # the width of the bars\n            multiplier = 0\n            fig, ax = plt.subplots(layout='constrained')\n            for attribute, measurement in pol_influ.items():\n                offset = width * multiplier\n                rects = ax.bar(x + offset, measurement, width, label=attribute)\n                ax.bar_label(rects, padding=3)\n                multiplier += 1\n            ax.set_ylabel('µg/m³')\n            ax.set_title('Influence du type de mesure à ' + str(villes[0]))\n            ax.set_xticks(x + width, polluants)\n            ax.legend(loc='upper left') #ncols=3\n            h = pol_influ.max().max() + 10\n            ax.set_ylim(0, h)\n            return fig\n        return graph_influ()\napp = App(app_ui, server, debug=True)\n\n\n\n\n\n\n\nReprésentation par jour de la semaine\n#| standalone: true\n#| viewerHeight: 800\n#| column: page\nfrom pprint import pformat\nimport pyodide.http\nfrom shiny import App, reactive, render, ui\nimport pandas as pd\nimport numpy as np\nfrom datetime import datetime\nimport matplotlib.pyplot as plt\n\n#les villes\nzone_atmos=\"'AGDE'\",\"'ALES'\",\"'ARGELES-GAZOST'\",\"'AUCH'\",\"'BELESTA-EN-LAURAGAIS'\",\"'BESSIERES'\",\"'BEZIERS'\",\"'BLAGNAC'\",\"'CORNEILHAN'\",\"'GAUDONVILLE'\",\"'LA CALMETTE'\",\"'LATTES'\",\"'LOURDES'\",\"'LUNEL-VIEL'\",\"'MIRAMONT-DE-COMMINGES'\",\"'MONTGISCARD'\",\"'MONTPELLIER'\",\"'NIMES'\",\"'PEYRUSSE-VIEILLE'\",\"'SAINT-GAUDENS'\",\"'SAINT-GIRONS'\",\"'SAZE'\",\"'TARBES'\",\"'TOULOUSE'\"     \n\n#les polluants\npolluant_atmos=\"'O3'\",\"'NO2'\",\"'NO'\",\"'NOX'\",\"'H2S\",\"'PM10'\",\"'PM2.5'\",\"'SO2'\"\n\napp_ui = ui.page_fluid(\n            ui.div(\n                ui.input_selectize(\"selection1\", \"Ville\", zone_atmos,multiple = True),\n                ui.input_selectize(\"condition1\", \"Polluant\", polluant_atmos, multiple = True),\n                class_=\"d-flex gap-3\"\n            ),\n            ui.output_plot(\"GRAPH_WEEK\",height='800px'),\n        )\n\n\ndef server(input, output, session):\n    def url2():\n        cond1 = \"where=(nom_poll=\"+ ') AND ('.join(input.condition1())+')'\n        cond2 =  \"AND (nom_com=\"+'AND ('.join(input.selection1())+')'\n        return f\"https://services9.arcgis.com/7Sr9Ek9c1QTKmbwr/arcgis/rest/services/Mesure_horaire_(30j)_Region_Occitanie_Polluants_Reglementaires_1/FeatureServer/0/query?{cond1}{cond2}&outFields=nom_com,nom_station,nom_poll,valeur,date_debut&outSR=4326&f=json\"\n\n    @reactive.Calc\n    async def data():\n        response2 = await pyodide.http.pyfetch(url2())\n        dat2 = await response2.json()\n        r = dat2,dat2\n        return r\n\n    @output\n    @render.plot\n    async def GRAPH_WEEK():\n\n        '''\n        fonction qui \n            - récupère le résultat de l'appel issu de data()\n            - transforme en dataframe\n            - trace le graphique de l amoyenne des jours selon le polluants choisi et la ville choisie\n        '''\n    \n        #supprimer les warnings\n        pd.options.mode.chained_assignment = None  # default='warn'\n\n        response = await data()\n        dat = response[1]\n\n        records = dat.get('features', [])\n        records_data = [record['attributes'] for record in records]\n        df_atmo = pd.DataFrame(records_data)\n\n        # datetime\n        df_atmo[\"date_debut\"] = df_atmo[\"date_debut\"]/1000\n        df_atmo[\"date_debut\"] = df_atmo[\"date_debut\"].apply(\n                    lambda _: datetime.utcfromtimestamp(_)\n                )\n\n        # liste des villes et des polluants\n        villes = df_atmo[\"nom_com\"].unique().tolist()\n        polluants = df_atmo[\"nom_poll\"].unique().tolist()\n\n        # Fonction qui trace le graphique\n        def graph_week():\n            #suppression station double\n            if villes == \"MONTPELLIER\":\n                df_atmo[\"nom_station\"] = df_atmo[\"nom_station\"].replace([\"Montpelier Pere Louis Trafic\"], \"Montpelier Antigone Trafic\")\n            #sélection : pas utile\n            df_pv = df_atmo\n            #les différentes stations\n            nom_stations = df_pv[\"nom_station\"].unique()\n            nb_stations = len(nom_stations)\n            \n            ####cas limite 1 station\n            if nb_stations == 1:\n                fig, axes = plt.subplots(1, 1, figsize=(10, 25), layout=\"constrained\")  # Créer une seule sous-figure\n                axes = [axes]  # Mettre l'unique axe dans une liste\n            else:\n                fig, axes = plt.subplots(nb_stations, 1, figsize=(10, 25), sharex=True, layout=\"constrained\")\n            \n            #titre général\n            fig.suptitle(\"Pollution selon le jour de la semaine à \" + str(villes[0]), fontsize=12)\n            # pour la légende\n            jour = [\"lundi\", \"mardi\", \"mercredi\",\"jeudi\", \"vendredi\", \"samedi\", \"dimanche\"]\n            for i in range(nb_stations):\n                # on ne garde que les données concernant la station en question             \n                df_pvs = df_pv.loc[df_pv[\"nom_station\"] == nom_stations[i]]\n                #datetime devient index\n                df_pvs = df_pvs.set_index([\"date_debut\"])\n                # colonne avec le numéro des jours\n                df_pvs[\"weekday\"] = df_pvs.index.weekday        \n                # on regroupe par jour et on fait la moyenne\n                pollution_week = (df_pvs.groupby([\"weekday\", df_pvs.index.hour])[\"valeur\"].mean().unstack(level=0))\n                # labellisation et légende\n                axes[i].plot(pollution_week)\n                axes[i].set_xticks(np.arange(0, 24))\n                axes[i].set_xticklabels(np.arange(0, 24), rotation=45)\n                axes[i].set_ylabel(\"µg/m3\")\n                axes[i].set_title(\"Concentration du \" + str(polluants[0]) + \" à \" + str(nom_stations[i]),fontsize = 12)\n                axes[i].legend(jour, loc=\"lower left\", bbox_to_anchor=(1, 0.1)).set_visible(True)\n                axes[i].grid(True)\n            return fig\n        return graph_week()\n    #@output\n    #@render.text\n    #async def info1():\n    #    if input.condition1() == \"\": #input.selection1() == \"\":\n    #        return \"\"\n    #    else:\n    #        d=await data()\n    #        df = d[1]\n    #        return f\"Request URL: {url2()}\\nResult type: {type(d[1])}\\n{df}\"\napp = App(app_ui, server, debug=True)"
  },
  {
    "objectID": "polluants/NOx.html",
    "href": "polluants/NOx.html",
    "title": "NOx : oxydes d’azotes",
    "section": "",
    "text": "Les oxydes d’azote (NOx) regroupent essentiellement deux molécules :\n\nle monoxyde d’azote (NO) ;\nle dioxyde d’azote (NO2).\n\nIl existe trois mécanismes de formation des oxydes d’azote, et donc trois types de NOx :\n\nles NOx thermiques, formés par combinaison chimique de l’oxygène et de l’azote de l’air lors d’une combustion à très haute température ;\nles NOx combustibles, issus de l’oxydation de l’azote présent dans les combustibles ;\nles NOx précoces, formés par combinaison chimique de l’azote de l’air avec des radicaux hydrocarbonés (CH et CH2, par exemple), qui se recombinent avec l’oxygène de l’air.\n\nLes sources d’émission des NOx\nLes oxydes d’azote proviennent essentiellement de procédés fonctionnant à haute température. Dans l’industrie, il s’agit des installations de combustion pour tout type de combustible (combustibles liquides fossiles, charbon, gaz naturel, biomasses, gaz de procédés…) et de procédés industriels (fabrication de verre, métaux, ciment…).\nLes principales sources d’émission de NOx sont :\n\nle transport routier ;\nles secteurs de l’industrie et de la production d’énergie.\n\nLes impacts des NOx sur la santé\nLe NO2 est un gaz irritant, qui pénètre dans les ramifications les plus fines des voies respiratoires. Il peut provoquer des difficultés respiratoires ou une hyperréactivité bronchique chez les personnes sensibles et favoriser l’accroissement de la sensibilité des bronches aux infections chez l’enfant. Le NO2 est 40 fois plus toxique que le monoxyde de carbone (CO) et quatre fois plus toxique que le NO.\nLes impacts des NOx sur l’environnement\nAssociés aux composés organiques volatils (COV), et sous l’effet du rayonnement solaire, les oxydes d’azote favorisent la formation d’ozone dans les basses couches de l’atmosphère (troposphère). En France, des dépassements des normes sanitaires dans l’air ambiant persistent, mais sont moins nombreux que par le passé. Les NOx contribuent aussi à la formation des retombées acides et à l’eutrophisation des écosystèmes. Les oxydes d’azote jouent enfin un rôle dans la formation de particules fines dans l’air ambiant."
  },
  {
    "objectID": "polluants/PM.html",
    "href": "polluants/PM.html",
    "title": "PM : particules fines",
    "section": "",
    "text": "Les particules fines (PM) regroupent regroupent deux types de molécules :\n\nPM10 : les particules de diamètre inférieur à 10 µm;\nPM2.5 : les particules de dimètre inférieur à 2,5 µm.\n\nSource\nLes sources des particules sont multiples et influent sur la composition chimique et la taille de ces de ces dernières.\nLa moitié des émissions de PM2.5 sont dues au secteur résidentiel et plus d’un quart au transport routier.\nImpact sur la santé\nAux concentrations auxquelles sont exposées la plupart des populations urbaines et rurales des pays développés et en développement, les particules ont des effets nuisibles sur la santé. L’exposition chronique contribue à augmenter le risque de contracter des maladies cardiovasculaires et respiratoires, ainsi que des cancers pulmonaires. Les effets sur la santé sont dépendants de la taille des particules. Les particules grossières, fraction comprise entre 2.5 µm et 10 µm, ont des effets sur la santé respiratoire. Concernant la fraction fine des particules, celles inférieures à 2.5 µm, elles impactent à long terme la santé cardiovasculaire.\nImpact sur l’environnement\nLes effets de salissure et de dégradation des monuments et bâtiments constituent les atteintes à l’environnement les plus visibles pour les particules."
  }
]